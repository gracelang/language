classes:
 binding
 collection
 emptySequence
 enumerable
 indexable
confidential:
 abstract
 lazySequenceOver()filteredBy
 lazySequenceOver()mappedBy
 max
constructors-of:binding:
 key()value
constructors-of:collection:
 TRAIT
constructors-of:emptySequence:
 iterator
constructors-of:enumerable:
 TRAIT
constructors-of:indexable:
 TRAIT
fresh-methods:
 dictionary
 iteratorConcat
 lazyConcatenation
 lazySequenceOver()filteredBy
 lazySequenceOver()mappedBy
 list
 range
 sequence
 set
fresh:dictionary:
 asString
 empty
 withAll
fresh:iteratorConcat:
 asDebugString
 asString
 hasNext
 next
fresh:lazyConcatenation:
 !=
 ++
 ::
 ==
 asDebugString
 asDictionary
 asList
 asSequence
 asSet
 asString
 basicAsString
 do
 do()separatedBy
 filter
 first
 fold()startingWith
 into
 isEmpty
 isMe
 iter
 iterator
 keysAndValuesDo
 map
 reduce
 size
 sizeIfUnknown
 sorted
 sortedBy
 values
 ≠
fresh:lazySequenceOver()filteredBy:
 !=
 ++
 ::
 ==
 asDebugString
 asDictionary
 asList
 asSequence
 asSet
 asString
 basicAsString
 do
 do()separatedBy
 filter
 first
 fold()startingWith
 into
 isEmpty
 isMe
 iter
 iterator
 keysAndValuesDo
 map
 reduce
 size
 sizeIfUnknown
 sorted
 sortedBy
 values
 ≠
fresh:lazySequenceOver()mappedBy:
 !=
 ++
 ::
 ==
 asDebugString
 asDictionary
 asList
 asSequence
 asSet
 asString
 basicAsString
 do
 do()separatedBy
 filter
 first
 fold()startingWith
 into
 isEmpty
 isMe
 iter
 iterator
 keysAndValuesDo
 map
 reduce
 size
 sizeIfUnknown
 sorted
 sortedBy
 values
 ≠
fresh:list:
 asString
 empty
 withAll
fresh:range:
 from()downTo
 from()to
 uncheckedFrom()to
fresh:sequence:
 asString
 empty
 fromprimitiveArray
 withAll
fresh:set:
 asString
 empty
 ofCapacity
 withAll
methods-of:binding.key()value:
 ==
 asString
 hash
 hashcode
 key
 value
methods-of:collection.TRAIT:
 asList
 asSequence
 asSet
 asString
 do
 do()separatedBy
 filter
 first
 fold()startingWith
 isEmpty
 iter
 iterator
 map
 reduce
 size
 sizeIfUnknown
methods-of:emptySequence.iterator:
 asString
 hasNext
 next
methods-of:enumerable.TRAIT:
 !=
 ++
 ::
 ==
 asDebugString
 asDictionary
 asList
 asSequence
 asSet
 asString
 basicAsString
 do
 do()separatedBy
 filter
 first
 fold()startingWith
 into
 isEmpty
 isMe
 iter
 iterator
 keysAndValuesDo
 map
 reduce
 size
 sizeIfUnknown
 sorted
 sortedBy
 values
 ≠
methods-of:indexable.TRAIT:
 !=
 ::
 asDebugString
 asDictionary
 asList
 asSequence
 asSet
 asString
 at
 basicAsString
 do
 do()separatedBy
 fifth
 filter
 first
 fold()startingWith
 fourth
 indexOf
 indexOf()ifAbsent
 indices
 into
 isEmpty
 isMe
 iter
 iterator
 keysAndValuesDo
 last
 map
 reduce
 second
 size
 sizeIfUnknown
 third
 ≠
methodtypes-of:Binding<K, T>:
 9 == -> Boolean
 9 hash -> Number
 9 key -> K
 9 value -> T
methodtypes-of:Block0<R>:
 1 apply -> R
methodtypes-of:Block1<T, R>:
 1 apply(a : T) -> R
methodtypes-of:Block2<S, T, R>:
 1 apply(a : S, b : T) -> R
methodtypes-of:Collection<T>:
 & 4
 & Iterable
 4 asList -> List<T>
 4 asSequence -> Sequence<T>
 4 asSet -> Set<T>
methodtypes-of:ComparableToDictionary<K, T>:
 9 at(_ : K)ifAbsent(_ : Unknown) -> T
 9 size -> Number
methodtypes-of:Dictionary<K, T>:
 & 9
 & Collection
 9 ++(other : Dictionary<K, T>) -> Dictionary<K, T>
 9 --(other : Dictionary<K, T>) -> Dictionary<K, T>
 9 ==(other : Object) -> Boolean
 9 asDictionary -> Dictionary<K, T>
 9 at(k : K) -> T
 9 at(key : K)ifAbsent(action : Block0<Unknown>) -> Unknown
 9 at(key : K)put(value : T) -> Dictionary<K, T>
 9 bindings -> Enumerable<Binding<K, T>>
 9 contains(elem : T) -> Boolean
 9 containsKey(k : K) -> Boolean
 9 containsValue(v : T) -> Boolean
 9 copy -> Dictionary<K, T>
 9 keys -> Enumerable<K>
 9 keysAndValuesDo(action : Block2<K, T, Done>) -> Done
 9 keysDo(action : Block1<K, Done>) -> Done
 9 removeAllKeys(keys : Iterable<K>) -> Dictionary<K, T>
 9 removeAllValues(removals : Iterable<T>) -> Dictionary<K, T>
 9 removeKey(key : K) -> Dictionary<K, T>
 9 removeValue(v : T) -> Dictionary<K, T>
 9 size -> Number
 9 values -> Enumerable<T>
 9 valuesDo(action : Block1<T, Done>) -> Done
methodtypes-of:Enumerable<T>:
 & 5
 & Collection
 5 asDictionary -> Dictionary<Number, T>
 5 into(existing : Expandable<Unknown>) -> Collection<Unknown>
 5 keysAndValuesDo(action : Block2<Number, T, Object>) -> Done
 5 sorted -> SelfType
 5 sortedBy(comparison : Block2<T, T, Number>) -> SelfType
 5 values -> Collection<T>
methodtypes-of:Expandable<T>:
 & 3
 & Iterable
 3 add(x : T) -> SelfType
 3 addAll(xs : Iterable<T>) -> SelfType
methodtypes-of:Iterable<T>:
 & 2
 & Object
 2 ++(other : Iterable<T>) -> Iterable<T>
 2 do(block1 : Block1<T, Done>) -> Done
 2 do(body : Block1<T, Done>)separatedBy(separator : Block0<Done>) -> Done
 2 filter(condition : Block1<T, Boolean>) -> Iterable<T>
 2 first -> T
 2 fold(binaryFunction : Block2<T, T, T>)startingWith(initial : T) -> Object
 2 isEmpty -> Boolean
 2 iterator -> Iterator<T>
 2 map(function : Block1<T, U>) -> Iterable<U>
 2 size -> Number
 2 sizeIfUnknown(action : Block0<Number>) -> Done
methodtypes-of:Iterator<T>:
 9 hasNext -> Boolean
 9 next -> T
methodtypes-of:List<T>:
 & 7
 & Sequence
 7 ++(o : List<T>) -> List<T>
 7 add(x : T) -> List<T>
 7 addAll(l : Iterable<T>) -> List<T>
 7 addAll(xs : Iterable<T>) -> List<T>
 7 addAllFirst(xs : Iterable<T>) -> List<T>
 7 addFirst(x : T) -> List<T>
 7 addLast(x : T) -> List<T>
 7 at(ix : Number)put(v : T) -> List<T>
 7 copy -> List<T>
 7 pop -> T
 7 remove(v : T) -> Done
 7 remove(v : T)ifAbsent(action : Block0<Done>) -> Done
 7 removeAll(vs : Iterable<T>) -> Done
 7 removeAll(vs : Iterable<T>)ifAbsent(action : Block0<Unknown>) -> Done
 7 removeAt(n : Number) -> T
 7 removeFirst -> T
 7 removeLast -> T
 7 reverse -> List<T>
 7 reversed -> List<T>
 7 sort -> List<T>
 7 sortBy(sortBlock : Block2<T, T, Number>) -> List<T>
methodtypes-of:MinimalyIterable:
 9 iterator -> Iterator
methodtypes-of:SelfType:
methodtypes-of:Sequence<T>:
 & 6
 & Enumerable
 6 at(n : Number) -> T
 6 contains(elem : T) -> Boolean
 6 fifth -> T
 6 fourth -> T
 6 indexOf(elem : T) -> Number
 6 indexOf(elem : T)ifAbsent(action : Block0<W>) -> Number | W
 6 indices -> Sequence<Number>
 6 keys -> Sequence<Number>
 6 last -> T
 6 reversed -> Sequence<T>
 6 second -> T
 6 size -> Number
 6 third -> T
methodtypes-of:Set<T>:
 & 8
 & Collection
 8 **(other : Set<T>) -> Set<T>
 8 ++(other : Set<T>) -> Set<T>
 8 --(other : Set<T>) -> Set<T>
 8 add(x : T) -> SelfType
 8 addAll(elements : Iterable<T>) -> SelfType
 8 contains(elem : T) -> Boolean
 8 copy -> Set<T>
 8 find(booleanBlock : Block1<T, Boolean>)ifNone(notFoundBlock : Block0<T>) -> T
 8 includes(booleanBlock : Block1<T, Boolean>) -> Boolean
 8 into(existing : Expandable<Unknown>) -> Collection<Unknown>
 8 isSubset(s2 : Set<T>) -> Boolean
 8 isSuperset(s2 : Iterable<T>) -> Boolean
 8 remove(x : T) -> Set<T>
 8 remove(x : T)ifAbsent(block : Block0<Done>) -> Set<T>
 8 removeAll(elems : Iterable<T>) -> Done
 8 removeAll(elems : Iterable<T>)ifAbsent(action : Block0<Done>) -> Set<T>
 8 size -> Number
modules:
path:
 collectionsPrelude
public:
 Binding
 Block0
 Block1
 Block2
 Collection
 ComparableToDictionary
 Dictionary
 Enumerable
 Expandable
 Iterable
 Iterator
 List
 MinimalyIterable
 SelfType
 Sequence
 Set
 collection
 dictionary
 enumerable
 indexable
 isEqual()toIterable
 iteratorConcat
 lazyConcatenation
 list
 range
 sequence
 set
types:
 Binding
 Block0
 Block1
 Block2
 Collection
 ComparableToDictionary
 Dictionary
 Enumerable
 Expandable
 Iterable
 Iterator
 List
 MinimalyIterable
 SelfType
 Sequence
 Set
