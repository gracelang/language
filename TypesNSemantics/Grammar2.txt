// top level
program ::=  {codeSequence}
codeSequence ::=  { repdel((declaration | statement), semicolon) }
innerCodeSequence ::=  { repdel((innerDeclaration | statement), semicolon) }

// declarations

declaration ::= { varDeclaration | defDeclaration | classDeclaration |
                  typeDeclaration | methodDeclaration }

innerDeclaration ::= { varDeclaration | defDeclaration | classDeclaration | 
                       typeDeclaration }

varDeclaration ::= { varId ~ identifier ~  opt(colon ~ typeExpression) ~ 
                     opt(assign ~ expression) }

defDeclaration ::= { defId ~ identifier ~  opt(colon ~ typeExpression) ~ 
                     equals ~ expression }

methodDeclaration ::= { methodId ~ methodHeader ~ methodReturnType ~ 
                        whereClause ~ lBrace ~ innerCodeSequence ~ rBrace }

classDeclaration ::= { classId ~ identifier ~ dot ~ classHeader ~ 
                       methodReturnType ~ whereClause ~
                       lBrace ~ codeSequence ~ rBrace }

methodHeader ::= { accessingAssignmentMethodHeader | accessingMethodHeader |  //warning: order is significant!
                   assignmentMethodHeader | methodWithArgsHeader | 
                   unaryMethodHeader | operatorMethodHeader | 
                   prefixMethodHeader  } 

classHeader ::= { methodWithArgsHeader | unaryMethodHeader }

unaryMethodHeader ::= { identifier ~ genericFormals } 
 
methodWithArgsHeader ::= { firstArgumentHeader ~ rep(argumentHeader) }

firstArgumentHeader ::= { identifier ~ genericFormals ~ methodFormals }

argumentHeader ::= { identifier ~ methodFormals }

operatorMethodHeader ::= { otherOp ~ oneMethodFormal } 

prefixMethodHeader ::= { token("prefix") ~ otherOp }  
                        // forbid space after prefix?

assignmentMethodHeader ::= { identifier ~ assign ~ oneMethodFormal }

accessingMethodHeader ::= { lrBrack ~ genericFormals ~ methodFormals }

accessingAssignmentMethodHeader ::= { lrBrack ~ assign ~ genericFormals ~ 
                                      methodFormals }

methodReturnType ::= { opt(arrow ~ nonEmptyTypeExpression )  } 

methodFormals ::= { lParen ~ 
                    rep1sep( identifier ~ opt(colon ~ typeExpression), comma) ~ 
                    rParen}

oneMethodFormal ::= { lParen ~ identifier ~ opt(colon ~ typeExpression) ~ rParen}

blockFormals ::= { repsep( identifier ~ opt(colon ~ typeExpression), comma) }

matchBinding ::= { (identifier | literal | parenExpression) ~ 
                   opt(colon ~ nonEmptyTypeExpression ~ opt(matchingBlockTail)) }

matchingBlockTail ::= { lParen ~ rep1sep(matchBinding, comma)  ~ rParen }


typeDeclaration ::= { typeId ~ identifier ~ genericFormals ~ equals ~ 
                      typeExpression ~ semicolon ~ whereClause}

typeExpression ::= { typeOpExpression  | opt(ws) }

nonEmptyTypeExpression ::= { typeOpExpression}

typeOp ::= { opsymbol("|") | opsymbol("&") | opsymbol("::::=") } 

typeOpExpression ::= { rep1sep(basicTypeExpression, typeOp) }

typeOpExpression ::= {    // this complex rule ensures two different typeOps have no precedence
  var otherOperator 
  basicTypeExpression ~
    opt( guard(typeOp, { s -> otherOperator := s; true }) ~
        rep1sep(basicTypeExpression ,
           guard(typeOp, { s -> s == otherOperator })
        )
    )
  } 

basicTypeExpression ::= { nakedTypeLiteral | literal | pathTypeExpression | 
                          parenTypeExpression }  
   // if we keep this, note it is formally ambiguous: in a typeExpression context { a; } is  interpreted as 
   // type { a; } otherwise as the block { a; }

pathTypeExpression ::= { opt(superId ~ dot) ~ rep1sep((identifier ~ genericActuals),dot) }

parenTypeExpression ::= { lParen ~ typeExpression ~ rParen } 

// statements

statement ::= { returnStatement | (expression ~ opt(assignmentTail)) } 
    // need constraints here on which expressions can have an assignmentTail
    // could try to rewrite as options including (expression ~ arrayAccess ~ assignmentTail)
    // expression ~ dot ~ identifier ~ assignmentTail 
     
returnStatement ::= { symbol("return") ~ opt(expression) }  //doesn't need parens

assignmentTail ::= { assign ~ expression }

// expressions

expression ::= { opExpression } 

opExpression ::= { rep1sep(addExpression, otherOp)}

opExpression ::= {    // this complex rule ensures two different otherOps have no precedence
  var otherOperator 
  addExpression ~ 
    opt( guard(otherOp, { s -> otherOperator := s; true }) ~
        rep1sep(addExpression,
           guard(otherOp, { s -> s == otherOperator })
        )
    )
  } 

addExpression ::= { rep1sep(multExpression, addOp) }

multExpression ::= { rep1sep(prefixExpression, multOp) }

prefixExpression ::= { (rep(otherOp) ~ selectorExpression) | 
                       (rep1(otherOp) ~ superId) }  // can have !super 

selectorExpression ::= { primaryExpression ~ rep(selector) }

selector ::= { (dot ~ unaryRequest) | 
                      (dot ~ requestWithArgs) |
                      (lBrack ~ rep1sep(expression,comma) ~ rBrack)  
                    }

operatorChar ::= CharacterSetParser.new("!?@#$%^&|~::=::::=-*/><:.") // had to be moved up

//special  for operators: cannot be followed by another operatorChar
method opsymbol(s : String) {trim(token(s) ~ not(operatorChar))}

multOp ::= op "*" | op "/" 

def addOp = op "+" | op "-" 

otherOp ::= { guard(trim(rep1(operatorChar)), { s -> ! parse(s) with( reservedOp ~ end ) })}  // encompasses multOp and addOp

operator ::= { otherOp | reservedOp }  

unaryRequest ::= { trim(identifier) ~ genericActuals ~ not(delimitedArgument) } 

requestWithArgs ::= { firstRequestArgumentClause ~ 
                      rep(requestArgumentClause) }

firstRequestArgumentClause ::= { identifier ~ genericActuals ~ 
                                 delimitedArgument }

requestArgumentClause ::= { identifier ~ delimitedArgument }

delimitedArgument ::= { argumentsInParens | blockLiteral | stringLiteral }

argumentsInParens ::= { lParen ~ rep1sep(expression, comma) ~ 
                         rParen  }  

implicitSelfRequest ::= { requestWithArgs |  rep1sep(unaryRequest,dot) }

primaryExpression ::= { literal | nonNakedSuper | implicitSelfRequest | parenExpression }  

parenExpression ::= { lParen ~ rep1sep(expression, semicolon) ~ rParen } 
                                      // TODO should parenExpression be around a codeSequence?

nonNakedSuper ::= { superId ~ not(not( operator|lBrack )) }

// "generics" 

genericActuals ::= { opt(lGeneric rep1sep(typeExpression, comma)  ~ rGeneric) }

genericFormals ::= { opt(lGeneric ~  rep1sep(identifier, comma)  ~ rGeneric) }

whereClause ::= { repdel(whereId ~ typePredicate, semicolon) }

typePredicate ::= { expression }

// TODO - wherever genericFormals appear, there should be a whereClause nearby.


// "literals"


literal ::= { stringLiteral | selfLiteral | blockLiteral | numberLiteral | 
              objectLiteral | tupleLiteral | typeLiteral } 

stringLiteral ::= { doubleQuote ~ rep( stringChar ) ~ doubleQuote } 

stringChar ::= { (drop(backslash) ~ escapeChar) | anyChar | space}

blockLiteral ::= { lBrace ~ opt( (matchBinding | blockFormals) ~ arrow) ~ innerCodeSequence ~ rBrace }

selfLiteral ::=  "self" 

numberLiteral ::= trim(DigitStringParser.new)

objectLiteral ::= { objectId ~ lBrace ~ codeSequence ~ rBrace }

tupleLiteral ::= { lBrack ~ repsep( expression, comma ) ~ rBrack }

typeLiteral ::= { typeId ~ nakedTypeLiteral | baseType }

baseType ::= Number | Boolean | String  // added by Kim 

nakedTypeLiteral ::= { lBrace 
                       repdel( methodHeader ~ methodReturnType, (semicolon | whereClause)) ~ rBrace }

// terminals

backslash ::= token "\\"    // doesn't belong here, doesn't work if left below!

doubleQuote ::= token "\""

space ::= token " " 

semicolon ::= { (symbol(";") ~ opt(trim(newLine))) }

colon ::= {both( ":",not(assign))}

newLine ::=  "\n" 

lParen ::=  "("

rParen ::=  ")" 

lBrace ::=  "\{"

rBrace ::=  "\}"

lBrack ::=  "["

rBrack ::=  "]"

lrBrack ::=  "[]"

arrow ::=  "->"

dot ::=  "."

assign ::=  ":::="

equals ::=  "::="

lGeneric ::= token "<"

rGeneric ::= token ">"

comma ::= { symbol(",") }

escapeChar ::= CharacterSetParser.new("\\\"'\{\}bnrtlfe ")

anyChar ::= CharacterSetParser.new("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890~!@#$%^&*()_-::::=::=[]|\:;<,>.?/")

identifierString ::= trim(GraceIdentifierParser.new)
// 
identifier ::= { bothAll(trim(identifierString),not(reservedIdentifier))  }   // bothAll ensures parses take the same length
// 
identifier ::= rule{both(identifierString,not(reservedIdentifier))  }   // both doesn't ensure parses take the same length

identifier ::= { guard(identifierString, { s -> ! parse(s) with( reservedIdentifier ~ end ) })}  // probably works but runs out of stack

superId ::= "super" 

extendsId ::= "extends"

classId ::= "class" 

objectId ::= "object" 

typeId ::= "type" 

whereId ::= "where" 

defId ::= "def" 

varId ::= "var" 

methodId ::= "method" 

prefixId ::= "prefix" 

interfaceId ::= "interface"


reservedIdentifier ::= {selfLiteral | superId | extendsId |
          classId | objectId | typeId | whereId |
          defId | varId | methodId | prefixId | interfaceId } // more to come


reservedOp ::= {assign | equals | dot | arrow | colon | semicolon}  // this is not quite right


