
\pagebreak
\section{Type-checking rules}\label{app::typeassn}

Typing rules return a triple $\pair{\tau,C,E}$ where $\tau$ is the type 
of the expression and $C$ and $E$ are the new type and variable 
environments resulting from processing the expression.

For simplicity in the following we ignore the rules for
\emph{innerCodeUnit} and \emph{innerCodeSequence}s as they duplicate those for \textit{codeUnit}
and \emph{codeSequence}.
Similarly, we generally assume that optional items are included in
syntactic constructs.  It is trivial to write the rules without those
items.

We will also assume that all ``self-inflicted'' method invocations 
(message sends to ``self'') include an explicit ``self'' receiver.

\paragraph{Rules}\ \\
\infrule
{C,E \vdash e\ \diamond \ \pair{\tau,C',E'} \ \ 
C \vdash \tau \leS \tau'}
{C,E \vdash e\ \diamond \ \pair{\tau',C',E'}}
{}{Subsumption }
		     


\infrule
{C,E \vdash codeUnit\ \diamond \ \pair{\tau',C',E'} \ \ 
C',E' \vdash codeSequence\ \diamond \ \pair{\tau'',C'',E''}}
{C,E \vdash codeUnit\ codeSequence\ \diamond \ \pair{\tau'',C'',E''}}
{}{\mathit{CodeSeq} }
		     
\infrule
{C \vdash \tau \leS \Done}
{C,E \vdash \texttt{var}\ \emph{x}: \tau \ \ \diamond \ 
\pair{\Done, C, E\addEnv \{x:\rf\ \tau \}}}
{}{\mathit{VarDcl} }

\infrule
{C,E \vdash \emph{exp} \diamond \pair{\tau,\_,\_}}
{C,E \vdash \texttt{var}\ x:\tau := \emph{exp}\ \ \diamond \ 
\pair{\Done, C, E\addEnv \{x:\rf\ \tau \}}}
{}{\mathit{VarDclInit}}


\infrule
{C,E \vdash \emph{exp}:\pair{\tau,\_,\_} }
{C,E \vdash \texttt{def}\ x: \tau\  = \emph{exp}\ \ \diamond \ 
\pair{\Done, C, E\addEnv \{x:\tau \}}}
{}{\mathit{DefDcl} }

\infrule
{C \addEnv \emph{newConstraints},
E\addEnv \emph{methodFormals} \vdash innerCodeSequence \diamond\ 
\pair{\tau,\_,\_} \ }
{\begin{array}{c}
C,E \vdash \texttt{method}\ \emph{id}\ \emph{genericFormals}\  
(\emph{methodFormals}) \ra \tau\ \\ 
\hspace*{5em}    
           \emph{typeConstraints}\ 
	   \{ innerCodeSequence \} \diamond \pair{\Done, C, E}  
\end{array}}
{}{\mathit{MethodDcl}}

In the above, if \texttt{genericFormals} is empty, then
\emph{newConstraints} is empty.  
Otherwise if \emph{typeConstraints} = $[ t_{1} \leS T_{1},\ldots, t_{n}
\leS T_{n}]$ and U is the set of types in \emph{genericFormals} that
do not occur on the left side of a type constraint in
\emph{typeConstraints}, then \\
\emph{newConstraints} = $\{t_{1} \leS
T_{1},\ldots, t_{n} \leS T_{n}\} \cup \{t \leS \Void\ |\ t \in U \}$.\\
We require $t_{1},\ldots,t_{n}$ from \texttt{typeConstraints} to all
occur in \emph{genericFormals}.

\emph{Note that the method id will be added to C when the class as a
whole is type-checked rather than here.}
		      		      
\axiom{
\begin{array}{c}
C,E \vdash \texttt{type}\ \emph{typeId}\ \emph{genericFormals} = 
        \emph{typeExpression}\ \diamond \\
	\pair{\Done, C \addEnv \{\emph{typeId} = \texttt{TFunc}(
	\emph{genericFormals)\ typeExpression} \},E }
\end{array}}
{\mathit{TypeDef}} 

\infrulebig
{\begin{array}{c}
C,E' \vdash \emph{codeSequence} \diamond \pair{\_,\_,\_},\\
C,E \vdash \emph{supObj} \diamond \pair{\sigma,\_,\_}
\end{array}}
{\begin{array}{l}
C,E \vdash \texttt{object}\  \{ \texttt{inherits}\ \emph{supObj} \\ \hspace*{7 em}
  \emph{codeSequence}  \} \diamond \pair{\tau,C,E}
\end{array}}
{}{\mathit{Object} }

%\pagebreak
$\begin{array}{l@{}l}
\textrm{where } &\sigma' =
\{m'_{1}:\sigma'_{1},\ldots,m'_{p}:\sigma'_{p}\} \emph{be the type formed by
the declared types of all public and }\\
&\emph{confidential methods of supObj.  It is an extension of}\ \sigma.\\
&\tau = \{m_{1}:\tau_{1},\ldots,m_{n}:\tau_{n}\} \emph{is the subtype
of $\sigma$ formed by adding the declared types of all}\\
& \emph{new public methods}.\\
&\tau' = \{m_{1}:\tau_{1},\ldots,m_{k}:\tau_{k}\} 
\emph{is the subtype of $\sigma'$ formed by adding the declared types of all 
new}\\& \emph{methods, including confidential and private methods}.\\
&E' = E \addEnv \{\texttt{self}:\tau', \texttt{super}:\sigma'\}\\
\end{array}$

Note that $\tau$ and $\tau'$ include the types of the implicit methods
generated by the public and confidential defs and variable 
declarations.  If \texttt{self} is passed out as a parameter then its 
type must be restricted to $\tau$.  Keyword \texttt{super} may only 
be used as a receiver of method requests.

A class of the form

$$\begin{array}{l}\texttt{class}\ \emph{classId}\  \emph{genericFormals}\  
\emph{methodFormals}\\ 
\hspace*{6em} \ra \ \emph{typeExp}\ \emph{typeConstraints} \\
\hspace*{3em} \{  \texttt{inherits}\ \emph{supObj} \\
\hspace*{3em}\ \emph{codeSequence}\}
\end{array}$$

can be translated as

$$\begin{array}{l}\texttt{method}\ \emph{classid} \  \emph{genericFormals}\  
\emph{methodFormals}\\ 
\hspace*{6em} \ra \ \emph{typeExp}\ \emph{typeConstraints} \\
\hspace*{3em} \texttt{object}\ \{  \texttt{inherits}\ \emph{supObj} \\
\hspace*{6.8em}\ \emph{ codeSequence} \}\\
\}
\end{array}$$

and type-checked via the translation.



% First, we give the typing rule for classes without inheritance.
% \infrulebig
% {\begin{array}{c}
% C',E' \vdash defDecl_{i} \diamond X, \\
% C',E'\vdash varDecl_{i} \diamond X', \\
% C',E' \vdash methodDecl_{i} \diamond \pair{\tau_{i},\ldots,\ldots}\\
% C,E \vdash \tau \leS typeExp
% \end{array}}
% {\begin{array}{l}
% C,E \vdash \texttt{class}\ \emph{classId.constrId}\  \emph{genericFormals}\  
% \emph{methodFormals}\  \emph{typeConstraints}\\ 
% \hspace*{6em} \ra \emph{typeExp}\ \emph{typeConstraints} \\
% \hspace*{6em} \{  \emph{codeSequence}  \} \diamond \pair{\Void,C,E''}
% \end{array}}
% {}{Class }
% 
% %\pagebreak
% $\begin{array}{l@{}l}
% \textrm{where } &\tau' = \{m_{1}:\tau_{1},\ldots,m_{n}:\tau_{n}\} 
% \emph{is the type formed by the types of all methods}.\\
% &\tau = \{m_{1}:\tau_{1},\ldots,m_{k}:\tau_{k}\} 
% \emph{is the type formed by the types of all public methods}.\\
% &C' = C \addEnv \emph{newConstraints} \\
% &E' = E \addEnv \emph{methodFormals} \addEnv \{\texttt{self}:\tau'\}\\
% &E'' = E \addEnv \{\emph{classId: \{constrId\ genericFormals\  
%  methodFormals} 
% \rightarrow \emph{typeExp typeConstraints}\}.
% \end{array}$
% 
% Note:  Must tweak this if \texttt{self} is 
% passed out via return statement or is passed as a parameter.  In my 
% book, accomplished this by inserting a \textit{close} function to 
% apply to \texttt{self} before releasing it to the wild.  Can be 
% handled as a syntactic insert during parsing. 
% 
% Now with inheritance:
% 
% \infrulebig
% {\begin{array}{c}
% C',E' \vdash defDecl_{i} \diamond X, \\
% C',E' \vdash varDecl_{i} \diamond X', \\
% C',E' \vdash methodDecl_{i} \diamond \pair{\tau_{i},\ldots,\ldots}\\
% C,E \vdash \tau \leS typeExp
% \end{array}}
% {\begin{array}{l}
% C,E \vdash \texttt{class}\ \emph{classId.constrId}\  \emph{genericFormals}\  
% \emph{methodFormals}\\ 
% \hspace*{6em} \ra \ \emph{typeExp}\ \emph{typeConstraints} \\
% \hspace*{6em} \{  \texttt{inherits}\ \emph{sc.const}\pair{t_{1}\ldots t_{n}}
% (e_{1},\ldots,e_{m}) 
% \\
% \hspace*{6em} \emph{codeSequence}  \} \diamond \pair{\Void,C,E''}
% \end{array}}
% {}{ClassInheritance }
% 
% The following needs to be adjusted for inheritance.  Need to specify
% overriding methods (including for confidential methods) are
% compatible.  Super must have access to public
% and confidential methods of superclass.  
% 
% $\begin{array}{l@{}l} \textrm{where }&\sigma' =
% \{m'_{1}:\sigma'_{1},\ldots,m'_{p}:\sigma'_{p}\} \emph{be the type formed by
% the types of all public and confidential methods of}\ \textit{sc}.\\
% &\tau' = \{m_{1}:\tau_{1},\ldots,m_{n}:\tau_{n}\} 
% \emph{is the type formed by the types of all methods of c}.\\
% &\tau = \{m_{1}:\tau_{1},\ldots,m_{k}:\tau_{k}\} 
% \emph{is the type formed by the types of all public methods of c}.\\
% &C' = C \addEnv \emph{newConstraints} \\
% &E' = E \addEnv \emph{methodFormals} \addEnv
% \{\texttt{self}:\tau',\texttt{super}:\sigma'\}\\
% &E'' = E \addEnv \{\emph{classId: \{constrId\ genericFormals\
% methodFormals} \rightarrow \emph{typeExp typeConstraints}\}.
% \end{array}$ If $m_{i}$ appears as a method name in $\sigma'$ with
% type $\sigma'_{j}$ then it is marked \texttt{override}, and $C, E''
% \vdash \tau_{i} \leS \sigma'_{j}$

\infrule {\begin{array}{c}
C,E \vdash \emph{obj} \diamond \pair{\{m:\pair{t_{1}\leS 
\tau_{1},\ldots, t_{n}\leS 
\tau_{n}} \gamma_{1}\cross \ldots \cross \gamma_{k} \rightarrow 
\tau\},\_,\_}\\
C \vdash \sigma_{i} \leS \tau_{i}\ \emph{for}\ 1 \leq i \leq n\\
C,E \vdash e_{j} \diamond \pair{ 
\gamma_{j}[t_{i}\mapsto\sigma_{i}],\_,\_} \emph{for}\ 1 \leq j \leq k
\end{array}} {C,E \vdash obj.m
\pair{\sigma_{1},\ldots,\sigma_{n}}(e_{1},\ldots,e_{k}) \diamond
\pair{\tau[t_{i} \mapsto \sigma_{i}],C,E}} {}{\mathit{MessageSend }}

\vspace{2ex}

\axiom
{C,E \vdash \texttt{numberLiteral}:\texttt{Number}}
{\mathit{NumberLit}}

\axiom
{C,E \vdash \texttt{stringLiteral}:\texttt{String}}
{\mathit{StringLit}}

\axiom
{C,E \vdash \texttt{true}:\texttt{Boolean}}
{\mathit{True}}

\axiom
{C,E \vdash \texttt{false}:\texttt{Boolean}}
{\mathit{False}}

\infrule{\begin{array}{c}
C,E \vdash \mathit{cond} \diamond \pair{\texttt{Boolean}, C', E'} \\  
C',E' \vdash \mathit{blk} \diamond \pair{\blkz{\tau},C'',E''}\\ 
C'',E'' \vdash \mathit{blk'} \diamond \pair{\blkz{\tau'},C''',E'''}
\end{array}}
{C,E \vdash \jf\ (\mathit{cond})\ \thn\ \mathit{blk}\ \els\ \mathit{blk'}
 \diamond \pair{\tau | \tau',C''',E'''}}
{}{\mathit{Cond} }

\axiom
{C,E \vdash x:\tau \ \ \ \ \ \ \ if\ \ \ E(x)=\tau}
{\mathit{Identifier}}


%\infrule
%{C,E \vdash exp_{1} \diamond \pair{T_{1},C_{1},E_{1}}, \ldots, 
%C_{n-1},E_{n-1} \vdash exp_{n}\diamond \pair{T_{n},C_{n},E_{n}}}
%{C,E \vdash \pair{exp_{1},\ldots,exp_{n}} \diamond 
%\pair{\emph{Tuple}_{n}<T_{1},\ldots,T_{n}>,C_{n},E_{n}}}
%{}{Tuple }



\infrule
{C,E \vdash x \diamond \pair{\rf\ \tau, C', E'} \ \ \  
C',E' \vdash M \diamond \pair{\tau',C'',E''}\ \ \ 
C',E' \vdash \tau' \leS \tau}
{C,E \vdash x
:=M \diamond \pair{\Done,C'',E''}}
{}{\mathit{Assn} }

\infrule
{C,E \vdash M \diamond \pair{\rf\ \tau , C', E'}}
{C,E \vdash M \diamond \pair{\tau , C', E'}}
{}{\mathit{R-Value }}

\emph{Perhaps we should just mark in the abstract syntax when we need 
the r-value rather than the l-value of a variable.}

Recall that blocks are abbreviations for objects with a single method apply.  The derived
rule would look like the following.
\infrule
{C,E\addEnv \{x_{1}:\tau_{1},\ldots,x_{n}:\tau_{n} \} \vdash M:\tau}
{C,E \vdash \{x_{1}:\tau_{1},\ldots,x_{n}:\tau_{n} \ra M \}: 
\{apply:\tau_{1} \cross \ldots \cross \tau_{n} \to \tau \} }
{}{\mathit{Block} }


\infrule{\begin{array}{c}
C,E \vdash \mathit{v} \diamond \pair{\tau, C_0, E_0} \\  
C_0,E_0 \vdash \mathit{blk_1} \diamond \pair{\blko{\sigma_1,\tau_1},C_1,E_1}\\ 
\ldots\\
C_{n-1},E_{n-1} \vdash \mathit{blk_n} \diamond \pair{\blko{\sigma_n,\tau_n},C_n,E_n}\\
C \vdash \tau \leS \sigma_1 | \ldots | \sigma_n
\end{array}}
{C,E \vdash \mtch(\mathit{v})\ \cs\ \mathit{blk_1}\ \ldots\ \cs\ \mathit{blk_n}
 \diamond \pair{\tau_1 | ... | \tau_n,C_n,E_n'}}
{}{\mathit{Match} }

Deal with cases like $\{7 \rightarrow "hello"\}$ later.

%% 
 % ******************************* STOP HERE *************************
 % 
 % \infrule
 % {C\addEnv \{t:\texttt{TYPE}\},E \vdash B:\tau \ }
 % {C,E \vdash \texttt{function}(t:\texttt{TYPE})\ B:\forall t.\tau }
 % {}{PolyFunction }
 % 
 % \infrule
 % {C\addEnv \{t \leI \gamma \},E \vdash B:\tau \ }
 % {C,E \vdash \texttt{function}(t \leI \gamma )\ B:\forall t \leI \gamma .\tau }
 % {}{\leI BdPolyFunction }
 % 
 % \infrule
 % {C\addEnv \{t<:\gamma \},E \vdash B:\tau \ }
 % {C,E \vdash \texttt{function}(t<:\gamma )\ B:\forall t<:\gamma .\tau }
 % {}{\leS BdPolyFunction }
 % 
 % \infrule {C,E \vdash M_1:\sigma \to \tau \ \ \ \ \ C,E \vdash
 % M_2:\sigma } {C,E \vdash M_1(M_2):\tau } {}{FuncAppl }
 % 
 % \infrule
 % {C,E \vdash M:\forall t.\tau \ \ \ \ \ C \vdash \sigma :TYPE}
 % {C,E \vdash M[\sigma ]:\tau [t\mapsto \sigma ]}
 % {}{PolyFuncAppl }
 % 
 % \infrule
 % {C,E \vdash M:\forall t \leI \gamma .\tau \ \ \ \ \ C \vdash \sigma
 % \leI \gamma }
 % {C,E \vdash M[\sigma ]:\tau [t\mapsto \sigma ]}
 % {}{\leI BdPolyFuncAppl }
 % 
 % \infrule
 % {C,E \vdash M:\forall t<:\gamma .\tau \ \ \ \ \ C \vdash \sigma <:\gamma }
 % {C,E \vdash M[\sigma ]:\tau [t\mapsto \sigma ]}
 % {}{\leS BdPolyFuncAppl }
 % 
 % \infrule
 % {C,E \vdash M_i:\tau _i\ and \ l_{i}\in {\cal L}\ for\ 1\le i\le n\ }
 % {C,E \vdash \{l_i=M_i:\tau_i\}_{i \le n}:\{l_i:\tau_i\}_{i \le n}}
 % {}{Record }
 % 
 % \infrule
 % {C,E \vdash M:\{l_i:\tau_i\}_{i \le n}}
 % {C,E \vdash M.l_i:\tau _i}
 % {\textrm{for all}\ 1\le i\le n}{Proj }
 % 
 % \infrulebig
 % {\begin{array}{c}
 % C,E \vdash M_a:\{iv_i:\forall \MT \leI \Tobj(\MT,\tau ).\sigma
 % _i,\}_{i \le k}\\
 % C,E \vdash M_b:\{m_j:\forall \MT \leI \Tobj(\MT,\tau ).\rjust\\
 % \hspace*{1.5in}
 % \forall \ST<:\RM(\sigma ).\MT\to \ST\to \tau_j\}_{j \le n}\rjust
 % \end{array}}
 % {C,E \vdash \texttt{class}(M_a,M_b):\Tclass(\MT,\sigma ,\tau )}
 % {}{Class }
 % $\begin{array}{l@{}l}
 % \textrm{where } &\tau = \{m_{j}:\tau_{j}\}_{j \le n},\ \ST\notin FV(\tau),\
 % \sigma = \{l_{i}:\sigma_{i}\}_{i \le k}, \textrm{ and} \\ &
 % \RM(\{l_{i}:\sigma_{i}\}_{i \le k}) =
 % \{l_{i}:\rf\ \sigma_{i}\}_{i \le k}
 % \end{array}$
 % \vspace{2ex}
 % 
 % \infrule
 % {C,E \vdash M:\Tclass(\MT,\sigma ,\tau )}
 % {C,E \vdash \texttt{new}\ M:\Tobj(\MT,\tau )}
 % {}{New }
 % 
 % \infrule {C \vdash \gamma  \leI \Tobj(\MT,\{m:\tau\})\ \ \ \ C,E
 % \vdash M:\gamma } {C,E \vdash M\Leftarrow m:(\tau[\MT\mapsto
 % \gamma ])} {}{Msg }
 % 
 % \infrulebig {\begin{array}{c} C,E \vdash
 % M:\Tclass(\MT,\{iv_i:\sigma_i\}_{i \le n},
 %   \{m_j:\tau_j\}_{j \le k})\\
 % C\addEnv \{\MT \leI \Tobj(\MT,\{m_j: \tau'_j\}_{j \le k+1})\}\vdash
 %   \tau'_1<:\tau _1\\
 % C,E \vdash M_1^V:\sigma_1^\forall\\
 % C,E \vdash M_{n+1}^V:\sigma_{n+1}^\forall\\
 % C,E \vdash M_1^f:\{m_j:\tau_j^\forall\}_{j \le k} \to \delta_1\\
 % C,E \vdash M_{k+1}^f:\{m_j:\tau_j^\forall\}_{j \le k}\to
 % \delta_{k+1}
 % \end{array}}
 % {\begin{array}{c}
 % C,E \vdash \texttt{class inherit}\ M\ \texttt{modifying}\ iv_1,m_1;\rjust\\
 % \hspace*{0.7in}(\{iv_1=M_1^V:\sigma _1^\forall
 % ,iv_{n+1}=M_{n+1}^V:\sigma _{n+1}^\forall \},\rjust\\
 % \hspace*{0.75in}\{m_1=M_1^f:\{m_j:\tau _j^\forall \}_{j \le k}\to \delta _1,\rjust\\
 % \hspace*{0.83in}m_{k+1}=M_{k+1}^f:\{m_j:\tau _j^\forall \}_{j \le
 % k}
 % \to \delta _{k+1}\}):\rjust\\
 % \hspace*{0.5in}\Tclass(\MT,\{iv_i:\sigma _i\}_{i \le n+1},
 % \{m_i:\tau'_i\}_{i \le k+1})\rjust
 % \end{array}}
 % {}{Inherits } 
 % $\begin{array}{l@{}l} \textrm{where } &\sigma_i^\forall
 % =\forall \MT \leI \Tobj(\MT,\{m_j:\tau'_{j}\}_{j \le k+1}).\sigma_i,
 % \textrm{ for } 1 \le i \le n+1,\\& \tau_l^\forall =\forall \MT \leI
 % \Tobj(\MT,\{m_j:\tau _j\}_{j \le n}).\\&
 % \hspace*{0.55in}\forall \ST<:\RTM(\{iv_i:\sigma _i\}_{i \le n}). 
 % \MT\to \ST\to \tau_l, \textrm{ for } 1 \le l \le k,\\& 
 % \delta_p=\forall \MT \leI
 % \Tobj(\MT,\{m_j:\tau'_j\}_{j \le k+1}).  \\& 
 % \hspace*{0.55in} \forall \ST<:\RTM(\{iv_i:\sigma _i\}_{i \le n+1}). 
 % \MT\to \ST\to \tau'_p, \textrm{ for } 1 \le p \le k+1\\
 % & \tau'_j=\tau_j\ \textrm{for } 2 \le j \le k, \textrm{and}\\&
 % \ST \not\in FV(\tau'_{1})\addEnv FV(\tau'_{k+1})
 % \end{array}$
 % 
 % \infrule
 % {C \vdash \sigma <:\tau \ \ \ \ \ C,E \vdash M:\sigma }
 % {C,E \vdash M:\tau }
 % {}{Subsump }
 % 
 % \infrule {\hat C,\hat E \vdash f: \sigma \to \tau \ \ and\ \ \rho \
 % \models_s\ \hat C,\hat E} {C,E \vdash \langle f,\rho \rangle
 % :\sigma_\rho \to \tau _\rho } {}{\textit{Closure }_{\to} }
 % 
 % \infrule {\hat C,\hat E \vdash f: \forall t.\tau \ \ and\ \ \rho \
 % \models_s\ \hat C,\hat E} {C,E \vdash \langle f,\rho \rangle
 % :\forall t.\tau_\rho } {}{\textit{Closure }_{\forall} }
 % 
 % \infrule {\hat C,\hat E \vdash f: \forall t \leI \gamma .\tau \ \ and\ \ \rho \
 % \models_s\ \hat C,\hat E} {C,E \vdash \langle f,\rho \rangle
 % :\forall t \leI \gamma_\rho.\tau_\rho } {}{\textit{Closure }_{\forall 
 % \leI} }
 % 
 % \infrule {\hat C,\hat E \vdash f: \forall t <: \gamma .\tau \ \ and\ \ \rho \
 % \models_s\ \hat C,\hat E} {C,E \vdash \langle f,\rho \rangle
 % :\forall t <: \gamma_\rho .\tau_\rho } {}{\textit{Closure }_{\forall<:} }
 % 
 % An analogous rule holds for polymorphic (resp. bounded polymorphic) functions.
 % %\infrule
 % %{\begin{array}{c}
 % %C,E\  \vdash M_a:(\RTM(\sigma )[\MT\mapsto \Tobj(\MT,\tau )])\\
 % %C,E \vdash M_b\ :\ \{\ldots ,m_j:\Tobj(\MT,\tau )\rjust\\
 % %\hspace*{1.6in}\to \RTM(\sigma )[\MT\mapsto \Tobj(\MT,\tau )]\rjust\\
 % %\hspace*{1.6in}\to \tau _j[\MT\mapsto \Tobj(\MT,\tau )],\ldots \}\rjust
 % %\end{array}}
 % %{C,E \vdash obj(M_a,M_b)\ :\ \TobjV(\MT,\sigma ,\tau )}
 % %{}{Object }
 % 
 % \infrule {\begin{array}{c}
 % C,E\  \vdash M_a:(\RTM(\sigma )[\MT\mapsto \Tobj(\MT,\tau )])\\
 % C,E \vdash M_b\ :\ \{m_j:(\MT \to \RTM(\sigma ) \to \tau
 % _j)\rjust\\
 % \hspace*{1.9in}[\MT\mapsto \Tobj(\MT,\tau )] \}_{j\leq m}\rjust
 % \end{array}}
 % {C,E \vdash \texttt{obj}(M_a,M_b)\ :\ \Tobj(\MT,\tau )} %TobjV
 % {}{Object}
 %%
 
 Not done yet:
 \begin{itemize}
 \item try-catch, should have the type obtained by variant of the try and catch blocks
 \item module, should be like object, but has imports to be dealt with
 \item array (should be line-ups)
 \item generics
 \item import statement
 \item return: method with return should return the type of the value returned | last expression.
 \item dialect
 \end{itemize}
 
 

