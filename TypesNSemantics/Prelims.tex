\section{Preliminary Definitions}\label{sec::prelims}

\begin{definition} Let ${\cal V}$ be an infinite collection of type
variables, ${\cal L}$ be an infinite collection of labels, and
${\cal C}$ be a collection of type constants that includes at
least the type constants Boolean, Number, \Void, and
\Done.
The simple pre-type expressions, {PreType}, and record pre-type
expressions, {PreRecType}, of Grace with respect to ${\cal V}$,
${\cal L}$, and ${\cal C}$ are given by the following context-free
grammar.  We assume $t, t_{i} \in {\cal V}$, $c \in {\cal C}$, and $m_i \in
{\cal L}$ in the following.

$$\begin{array}{l@{}l@{}l} \tau\ \in\ \textit{PreType}\ &::=\ &t\ |\ c\
|\ \mbox{\tt ref}\ \tau\ |\ 
\tau_1 \cross \ldots \cross \tau_n \to \tau \ |\ 
%\pair{t_{1},\ldots,t_{n}}\tau \ |\
\forall{ t_{1} \leS \tau_{1},\ldots,t_{n} \leS \tau_{n}}.\tau\ | \\&& 
\{m_1: \tau_1;\ldots; m_n: \tau_n\}\ |\ 
<l_1: \tau_1 , \ldots, l_n: \tau_n >
\end{array}$$

\end{definition}

Type \Void\ will stand for the type of an
imperative command expression, i.e., an expression that does not 
return a value.  The type
\texttt{Object} is a supertype of all object types, and (in our current
implementation) contains \texttt{asString} and \texttt{asDebugString}
methods that are (implicitly) inherited by all object types.

Reference types are the types of variables.  That is, if $x$ is a variable
holding values of type $\tau$, then $x$ has type \texttt{ref} $\tau$.
This notation allows us to distinguish between values of type $\tau$ and
variables that hold values of that type.

As is standard, the type $\tau_1 \cross \ldots \cross \tau_n \to \tau$
is the type of functions taking parameters of type $\tau_{1}$ through
$\tau_{n}$ and returning a value of type $\tau$.  The type $\forall{
t_{1} \leS \tau_{1},\ldots,t_{n} \leS \tau_{n}}.\tau$ represents bounded
polymorphic functions (that is functions that take types as
parameters).  Unbounded polymorphic functions can be represented by
terms of the form $\pair{ t_{1} \leS \texttt{Object},\ldots,t_{n} \leS
\texttt{Object}}.\tau$.  The identifiers $t_{i}$ are bound by these type
expressions.  As usual we identify polymorphic types that are the same
up to renaming of the bound variable.

The type $\{m_1: \tau_1;\ldots; m_n: \tau_n\}$ represents the type of 
an object with public methods $m_{1},\ldots,m_{n}$.  On the other hand
the type $<l_1: \tau_1 , \ldots, l_n: \tau_n >$ represents a tagged variant
type.  A typical element, written $<l_i = e_i>$, has the type if $e_i$ has type
$\tau_i$ 

We will use the abbreviation $\blkz {,\sigma}$ to stand for the type
$\{apply: \ra \sigma\}$, $\blko {\tau,\sigma}$ to stand for the type
$\{apply: \tau \ra \sigma\}$, etc.

The axioms and rules for determining valid types and constructors are
given with respect to a set, $C$, of simple type constraints,
which provide information about free type variables.  The definition
of type constraints, the rules for determining valid types and
constructors, and the matching and subtyping rules are mutually
recursive.

\begin{definition}
\label{Cdefinition}
Relations of the form $t \leS \tau$ and $t\ =
\tau$, where $t$ is a type variable and $\tau$ is a type expression,
are said to be \emph{simple type constraints\/}.  A \emph{type
constraint system}, $C$, is defined as follows:
\begin{enumerate}
\item The empty set, $\emptyset$, %change
is a type constraint system.
\item If $C$ is a type constraint system such that
  $C \tst \tau: {\tt TYPE}$, and $t$ is a type variable that
  does not appear in $C$,
  then $C \cup \{t \leS \tau\}$ is a type constraint system.
\item If $C$ is a type constraint system such that
  $C \tst \tau \leS \mbox{\tt Object}$, and $t$ is a type variable that
  does not appear in $C$ or $\tau$,
  then $C \cup \{t = \tau\}$ is a type constraint system.
\end{enumerate}
\end{definition}

In Figure \ref{def-types} we include axioms and
rules for determining which are the legal type and constructor
expressions.  In the \Tobj\ rule, the types of all
methods must be function or polymorphic function types.

\input{types} The axioms and rules for $\leS$ can be found in Figure
\ref{app::subtype}.  Reference types have no
non-trivial subtypes.  The subtyping rule for function types is
contravariant in the argument type and covariant in the result type.
The subtyping rules for polymorphic types support covariant changes in
the return type, but no changes in the bounds of the type parameters.
While the rules could be generalized to allow contravariant changes in
the type bounds, the decidability of subtyping would be lost.  The
subtyping rule for object types allows both depth and width subtyping.

\input{subtypes}

\pagebreak
\subsection{Grace Expression Syntax}

\begin{definition}
The set, PreTerm, of pre-terms of Grace over a set $\cal B$ of term
constants, a set ${\cal L}$ of labels, and a set $\cal X$ of term
identifiers is given by the following context-free grammar (we assume $x
\in {\cal X},\ b \in {\cal B},\ l,m \in {\cal L}$\ and \ $\sigma, \tau
\in PreType$).  The notation $\texttt{opt}(\textit{exp})$ indicates 
that \textit{exp} is optional in the syntax.\\
$$\begin{array}{l@{}l@{}l}
\textit{codeSequence} &::=\ &\textit{\textit{codeUnit}}\ 
\texttt{opt}(\textit{codeSequence}) \\
\textit{codeUnit} &::= &\textit{declaration}\ |\ \textit{statement}\\
\textit{declaration} &::= &\textit{varDeclaration}\ |\
\textit{defDeclaration}\ |\ \textit{classDeclaration}\ |\
\\ && \textit{typeDeclaration}\ |\ \textit{methodDeclaration}\\
\textit{statement} &::= & \textit{identifier := expression}\ | \kwd{\jf} (\mathit{expression}) \kwd{\thn}\ \mathit{block}\ \kwd{\els}\ \mathit{block}\\
\textit{innerCodeSequence} &::= & \textit{innerCodeUnit}\ 
\texttt{opt}(\textit{innerCodeSequence}) \\
\textit{innerCodeUnit} &::= &\textit{innerDeclaration}\ |\ \textit{statement}\\
\textit{innerDeclaration} &::= &\textit{varDeclaration} \ |\  
\textit{defDeclaration} \ |\ \textit{classDeclaration} \ |\\&&  
                       \textit{typeDeclaration} \\
\textit{varDeclaration} &::= &\kwd{var } \textit{identifier}\ : \textit{typeExpression}  
                     \texttt{ opt}(:= \textit{expression}) \\
\textit{defDeclaration} &::= & \kwd{def}\ \textit{identifier} : 
   \textit{typeExpression} = \textit{expression}\\
\textit{methodDeclaration} &::= &\kwd{method}\ \textit{identifier}\  
\texttt{opt}(\textit{genericFormals})\ \textit{methodFormals} \\&&
\ra \textit{nonEmptyTypeExpression}\ 
\texttt{opt}(\textit{typeConstraints})\\&&
\{ \textit{innerCodeSequence} \} \\
			
\textit{genericFormals} &::= &\dlb t_{1},\ldots,t_{n} \drb\\
\textit{methodFormals} &::= &(\textit{id}_{1}: 
\textit{typeExp}_{1},\ldots, \textit{id}_{n}: 
\textit{typeExp}_{n})\\

\textit{typeConstraints} &::= &\kwd{where}\ 
\textit{t}_{1} \leS \textit{typeExp}_{1},\ldots,
\textit{t}_{n} \leS \textit{typeExp}_{n}\\
\textit{typeDeclaration} &::= &\kwd{type}\ \textit{typeId}\ 
\texttt{opt}(\textit{genericFormals}) = 
                      \textit{typeExpression}\\
\textit{classDeclaration} &::= &\kwd{class}\ \textit{cid.constrId}\  
   \texttt{opt}(\textit{genericFormals}) \ 
   \texttt{opt}(\textit{methodFormals}) \\&&
   \rightarrow\ \textit{typeExp}\   
   \texttt{opt}(\textit{typeConstraints}) \\&&
   \{  \texttt{opt}(\kwd{inherit}\ \textit{scid}
   \pair{t_{1}\ldots t_{n}}
   (e_{1},\ldots,e_{m}))\\&&
   \textit{codeSequence}  \} \\
\textit{objectLiteral} &::= &\kwd{object} \{  \texttt{opt}(\kwd{inherit}\ \textit{scid}
   \pair{t_{1}\ldots t_{n}}
   (e_{1},\ldots,e_{m}))\\&&  \textit{codeSequence}  \} \\
\end{array}$$
\end{definition}

The only difference between \emph{declaration} and \emph{innerDeclaration} is that
\emph{innerDeclaration}s may not include method declarations.  The distinction is
necessary because a method declaration may not directly contain a method declaration
(though it can contain an object which itself has method declarations).
The type-checking axioms and rules for Grace are given in terms of a
type constraint system, $C$, as defined earlier, and an \emph{static type
environment}, $E$, which assigns types to free identifiers.

\begin{definition}
A \emph{static type environment}, $E$, (with respect to $C$) is a
finite set of associations between identifier and type expressions
of the form $x : \tau$, where each $x$ is unique in $E$ and $C \ts
\tau: \emph{\TP}$.  If the relation $x : \tau \in E$, then we write $E(x)
= \tau$.
\end{definition}

The collection \emph{Term} of terms of Grace with respect to
$C$, $E$ is the set of pre-terms that can be assigned types with
respect to the type-assignment axioms and rules in Section
\ref{app::typeassn}. 

The type-assignment rules provided in Section \ref{app::typeassn}
yield expanded type constraints and assignments as well as types.
These expanded type constraints assignments are used to type check the
rest of the program.  Thus an assertion of the form $C,E \vdash
\textit{M}\ \diamond \ \pair{\tau, C', E'}$ indicates that if a term
\textit{M} is processed under the type constraint system $C$ and
syntactic type assignment $E$, then \textit{M} has type $\tau$ and the
richer syntactic type constraint C' and type assignment $E'$ result.  
These richer sets will be used in type-checking later terms.
If \textit{M} is a command or declaration then the type $\tau$ will be
\Done.
