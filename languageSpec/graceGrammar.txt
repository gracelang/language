AliasClause ::= "alias" MethodHeader "=" MethodHeaderAnnotationArgList ::= "(" Expression  ( "," Expression )+  ")"        | Numeral        | String        | SequenceConstructor        | SpecialTerm        | "(" Expression ")"AnnotationLabel ::= <id>        | <id> TypeArguments AnnotationArgList  ( <id> AnnotationArgList )*         | <id> TypeArguments        | <id> AnnotationArgList  ( <id> AnnotationArgList )* Annotations ::= Empty        | "is" AnnotationLabel  ( "," AnnotationLabel )* ArgumentList ::= DelimitedTerm        | "(" Expression  ( "," Expression )+  ")"Assignment ::= Identifier ":=" Expression        | AssignmentRequestAssignmentMethodHeader ::= Identifier ":=" TypeParameterList SingleMethodParameterAssignmentRequest ::= Term <dot> <id> ":=" Expression        | "self" <dot> <id> ":=" Expression        | ( "outer" <dot> )+  <id> ":=" ExpressionBinaryMethodHeader ::= <operator> TypeParameterList SingleMethodParameterBinaryRequest ::= Factor  ( <operator> TypeArguments?  Factor )+ Block ::= "{" BlockParameterList "→" Ss?   ( Statement  ( Ss Statement )*  )? "}"        | "{"  ( Statement  ( Ss Statement )*  )? "}"BlockParameter ::= Identifier PatternOption        | NonIdExpressionBlockParameterList ::= BlockParameter  ( "," BlockParameter )* Boolean ::= "true"        | "false"ClassDeclaration ::= "class" MethodHeader ReturnTypeOption Annotations  ( "{"  ( ObjectItem  ( Ss ObjectItem )*  )? "}" )?Declaration ::= VarDeclaration        | DefDeclaration        | TypeDeclarationDefDeclaration ::= "def" Identifier TypeOption Annotations  ( "=" Expression )?DelimitedTerm ::= Numeral        | Block        | String        | SequenceConstructor        | SpecialTerm        | "(" Expression ")"Dialect ::= "dialect" StringLiteralDottedRequest ::= Term <dot> RequestPartEllipsis ::= "..."Empty ::= ExcludeClause ::= "exclude" MethodHeaderExpression ::= BinaryRequest        | FactorFactor ::= Term        | ObjectConstructor        | UnaryRequestIdentifier ::= <id>ImplicitRequest ::= RequestPartsWithArgumentsImport ::= "import" StringLiteral "as" Identifier AnnotationsInheritStatement ::= "inherit" Expression  ( ReuseModifier )* Interface ::= "interface" InterfaceLiteral        | "type" InterfaceLiteralInterfaceLiteral ::= "{" "}"        | "{"  ( Signature | TypeDeclaration )   ( Ss  ( Signature | TypeDeclaration )  )*  "}"MethodDeclaration ::= "once"? "method" MethodHeader ReturnTypeOption Annotations  ( "{"  ( Statement  ( Ss Statement )*  )? "}" )?MethodHeader ::= AssignmentMethodHeader        | ParameterizedMethodHeader        | ParameterlessMethodHeader        | BinaryMethodHeader        | UnaryMethodHeaderMethodParameter ::= Identifier TypeOptionMethodParameterList ::= "(" MethodParameter  ( "," MethodParameter )*  ")"Module ::= Ss?   ( Pragma Ss )*   ( Dialect Ss )?  ( ObjectItem Ss )*  ObjectItem? NonIdExpression ::= BinaryRequest        | NonIdFactorNonIdFactor ::= NonIdTerm        | ObjectConstructor        | UnaryRequestNonIdTerm ::= DelimitedTerm        | Interface        | UnknownType        | SelfType        | Request        | EllipsisNumeral ::= <decimalNumeral>        | <baseExponentNumeral>        | <explicitRadixNumeral>ObjectConstructor ::= "object" Annotations "{" ObjectItem  ( Ss ObjectItem )*  "}"        | "object" Annotations "{" "}"ObjectItem ::= Statement        | MethodDeclaration        | ClassDeclaration        | TraitDeclaration        | UseStatement        | InheritStatementOuter ::= "outer"        | ( "outer" <dot> )+  "outer"OuterRequest ::= ( "outer" <dot> )+  RequestPartParameterizedMethodHeader ::= <id> TypeParameterList MethodParameterList  ( <id> MethodParameterList )* ParameterlessMethodHeader ::= <id> TypeParameterListPatternOption ::= Empty        | ":" ExpressionPragma ::= "#pragma" <id>Request ::= ImplicitRequest        | SelfRequest        | OuterRequest        | DottedRequestRequestPart ::= RequestPartNoArguments        | RequestPartsWithArgumentsRequestPartNoArguments ::= <id>RequestPartsWithArguments ::= <id> TypeArguments ArgumentList  ( <id> ArgumentList )*         | <id> TypeArguments        | <id> ArgumentList  ( <id> ArgumentList )* Return ::= "return" Expression? ReturnTypeOption ::= Empty        | "→" TypeExpressionReuseModifier ::= ExcludeClause        | AliasClauseSelf ::= "self"SelfRequest ::= "self" <dot> RequestPartSelfType ::= "Self"SequenceConstructor ::= "[" "]"        | "[" Expression  ( "," Expression )*  "]"Signature ::= MethodHeader ReturnTypeOptionSingleMethodParameter ::= "(" MethodParameter ")"SpecialTerm ::= Self        | Outer        | BooleanSs ::= ";"        | <newline>        | Ss  ( ";" | <newline> ) Statement ::= Expression        | Declaration        | Assignment        | Return        | Import        | <error>String ::= StringLiteral        | StringConstructor        | UninterpretedStringStringConstructor ::=  <dquote> <stringSegment>?   (  "{" Expression  "}" <stringSegment>?  )+   <dquote>StringLiteral ::=  <dquote> <stringSegment>?   <dquote>Term ::= NonIdTerm        | IdentifierTraitDeclaration ::= "trait" MethodHeader ReturnTypeOption Annotations  ( "{"  ( ObjectItem  ( Ss ObjectItem )*  )? "}" )?Type ::= UnknownType        | SelfType        | Interface        | Identifier TypeArguments?         | Type <dot> RequestPartNoArguments TypeArguments?         | "(" TypeExpression ")"TypeArguments ::= "⟦" Type  ( "," Type )*  "⟧"TypeDeclaration ::= "type" Identifier TypeParameterList Annotations "=" TypeExpression Where        | "type" Identifier TypeParameterList Annotations "=" InterfaceLiteral WhereTypeExpression ::= Type  ( <typeOperator> TypeArguments?  Type )* TypeOption ::= Empty        | ":" TypeExpressionTypeParameter ::= IdentifierTypeParameterList ::= Empty        | "⟦" TypeParameter  ( "," TypeParameter )*  "⟧"UnaryMethodHeader ::= "prefix" <operator> TypeParameterListUnaryRequest ::= <operator> TypeArguments?  TermUninterpretedString ::=  "‹" <uninterpretedString>?   "›"UnknownType ::= "Unknown"UseStatement ::= "use" Expression  ( ReuseModifier )* VarDeclaration ::= "var" Identifier TypeOption Annotations  ( ":=" Expression )?Where ::= Empty        | "where" WhereCondition  ( "," WhereCondition )* WhereCondition ::= <id> <typeRelation> Type